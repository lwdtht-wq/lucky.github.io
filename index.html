<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sketch — SVG line-draw animation</title>
<style>
  :root { --ink: #2b2f77; --hover: #3b82f6; }
  html,body{margin:0;background:#fff;font-family:system-ui,Segoe UI,Arial}
  .wrap{max-width:960px;margin:28px auto;padding:0 16px}
  h1{margin:0 0 10px;font-size:26px}
  .sub{color:#666;margin:0 0 12px}
  #stage{border:1px solid #e5e7eb;border-radius:12px;padding:12px}
  svg{display:block;width:100%;height:auto;background:#fff; /* 保持纯白背景 */}
  /* 让笔触在缩放时保持宽度 */
  svg *{vector-effect:non-scaling-stroke}
  /* 悬停到任何笔触：轻微加粗并变色 */
  .hoverable:hover{stroke:var(--hover) !important; stroke-width:2.2 !important}
  /* 入场线描动画 */
  @keyframes draw {
    from { stroke-dashoffset: var(--segLen, 0); }
    to   { stroke-dashoffset: 0; }
  }
  /* 整体轻微漂浮 */
  @keyframes float {
    0%,100% { transform: translateY(0px); }
    50%     { transform: translateY(-2px); }
  }
  .floating{ animation: float 4s ease-in-out infinite; transform-origin:center }
  .toolbar{display:flex;gap:8px;margin-top:12px}
  button{
    padding:8px 12px;border:1px solid #e5e7eb;border-radius:8px;background:#111;color:#fff;
    cursor:pointer;font-size:14px
  }
  button:hover{filter:brightness(1.05)}
</style>
<body>
  <div class="wrap">
    <h1>Chart 9 (sketch) — animated</h1>
    <p class="sub">Auto line-draw + float + hover highlight. No changes to your original SVG file.</p>
    <div id="stage" class="floating"><!-- SVG will be injected here --></div>
    <div class="toolbar">
      <button id="replay">Replay</button>
    </div>
  </div>

<script>
const SVG_URL = '11.svg';          // ← 如果文件名不同，改这里
const STROKE_COLOR = getComputedStyle(document.documentElement)
                      .getPropertyValue('--ink').trim();

/**
 * 把外部 SVG 拉进来并添加动画
 */
async function loadAndAnimate() {
  const holder = document.getElementById('stage');
  holder.innerHTML = 'Loading…';
  const txt = await fetch(SVG_URL).then(r => r.text());
  holder.innerHTML = txt;

  const svg = holder.querySelector('svg');
  if (!svg) return;

  // 统一一下外观：不覆盖你原有的 fill，只是保证线条看起来漂亮
  svg.querySelectorAll('path,line,polyline,polygon,rect,circle,ellipse').forEach(el => {
    // 仅对有描边的元素做动画；如果没设 stroke，就给个默认颜色
    const computedStroke = el.getAttribute('stroke') || STROKE_COLOR;
    el.setAttribute('stroke', computedStroke);
    el.setAttribute('stroke-linecap','round');
    el.setAttribute('stroke-linejoin','round');
    el.classList.add('hoverable');
  });

  // 计算每段线总长度并做“描边绘制”动画，逐条错峰
  const drawables = Array.from(
    svg.querySelectorAll('path,line,polyline,polygon,rect,circle,ellipse')
  );

  let t = 0;                        // 累计延迟
  const STEP = 0.08;                // 每条相隔的错峰秒数
  const DUR  = 1.6;                 // 每条绘制时长

  drawables.forEach((el, i) => {
    // 有些元素（例如 group）没有长度；过滤掉
    if (typeof el.getTotalLength !== 'function') return;
    const len = el.getTotalLength();

    // 设置 dash 数值并应用动画
    el.style.strokeDasharray  = len;
    el.style.strokeDashoffset = len;
    el.style.setProperty('--segLen', len);
    el.style.animation = `draw ${DUR}s ease-out ${t.toFixed(2)}s forwards`;

    t += STEP;
  });

  // 让整幅图“漂浮”起来（不会影响描边粗细）
  svg.classList.add('floating');
}

// 重播：清除动画属性再重新加载
document.getElementById('replay').addEventListener('click', async () => {
  const stage = document.getElementById('stage');
  const backup = stage.innerHTML;   // 保底
  try {
    // 直接重新加载能重新计算长度并刷新动画
    await loadAndAnimate();
  } catch (e) {
    // 如果失败就回退
    stage.innerHTML = backup;
  }
});

// 初次加载
loadAndAnimate();
</script>
</body>
</html>
